实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2

示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

class Solution {
    public int mySqrt(int x) {
        if(x==1)
            return 1;
        long i=0l;
        long te=0l;
        for(i=0;i<=x/2;i++){
            te=i*i;
            if(Long.compare(te,x)>0){
                break;
            }
        }
        return (int)i-1;
    }
}

i必须用long类型。因为如果x是Integer.MAX_VALUE就会报错。
Long.compare(x,y)>0;




其他解法。
解法1：使用内置函数

虽然本题的意思肯定不是要使用内置函数，但是我们要知道有这样的库函数

class Solution {
public:
    int mySqrt(int x) {
        return sqrt(x);
    }
};

解法2：二分搜索

class Solution {
public:
    int mySqrt(int x) {
        //注：在中间过程计算平方的时候可能出现溢出，所以用long long。
        long long i=0;
        long long j=x/2+1;//对于一个非负数n，它的平方根不会大于（n/2+1）
        while(i<=j)
        {
            long long mid=(i+j)/2;
            long long res=mid*mid;
            if(res==x) return mid;
            else if(res<x) i=mid+1;
            else j=mid-1;
        }
        return j;
    }
};

解法3：牛顿迭代法 

https://matongxue.com/madocs/205.html
https://steve.blog.csdn.net/article/details/92024963


这种算法的原理很简单，我们仅仅是不断用 (x,f(x))(x, f(x))(x,f(x)) 的切线来逼近方程 x2−a=0x^2-a=0x2−a=0 的根。
根号 aaa 实际上就是 x2−a=0x^2-a=0x2−a=0 的一个正实根，这个函数的导数是 2x2x2x。
也就是说，函数上任一点 (x,f(x))(x,f(x))(x,f(x)) 处的切线斜率是 2x2x2x。
那么，x−f(x)/(2x)x-f(x)/(2x)x−f(x)/(2x) 就是一个比 xxx 更接近的近似值。
代入 f(x)=x2−af(x)=x^2-af(x)=x2−a 得到 x−(x2−a)/(2x)x-(x^2-a)/(2x)x−(x2−a)/(2x)，
也就是 (x+a/x)/2(x+a/x)/2(x+a/x)/2。

class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;
        double last=0;
        double res=1;
        while(res!=last)
        {
            last=res;
            res=(res+x/res)/2;
        }
        return int(res);
    }
};

int mySqrt(int x){ 
double res = 1; 
if( x == 0 || x == 1) 
     return x;
 while( fabs( res*res - x ) > 0.5)
 { // 相差小于0.5时退出循环
 res = ( res + x/res )/2; 
 } 
 return int(res); }

